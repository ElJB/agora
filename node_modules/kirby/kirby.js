var pgHelper = require('pg-helper'),
	EventEmitter = require('events').EventEmitter,
	Q = require('q');

var LOG = __filename + ": ";

var Kirby = function(dbConnect){
	var self = this;

	this.pg = new pgHelper(dbConnect),
	this.belly = {},
	this.contracts = {},
	this.ready = false;

	this.pg.getTables()
		.then(function(result){
			result.rows.forEach(function(row){
				self.belly[row.table_name] = true;
				self.createContract(row.table_name);
			});
			self.ready = true;
			self.emit("ready");
		}).catch(function(err){
			self.emit("err", err);
		});
}

Kirby.prototype.__proto__ = EventEmitter.prototype;

Kirby.prototype.swallow = function(fn){
	var deferred = Q.defer(),
		self = this;

	if( !this.ready ){
		throw new Error(LOG + "Not ready to swallow");
	}

	if( !fn.name ){
		throw new Error(LOG + "Anonymous function");
	}

	var name = fn.name.toLowerCase();

	function createFunction(){

		function digested(){
			var digestDeferred = Q.defer(),
				args = arguments;
			
			if( this.global === this ){
				var context = undefined;
			} else {
				var context = this;
			}

			self.pg.queryPromise("SELECT result FROM " + name + " WHERE args = " + self.pg.dollarize(JSON.stringify(args)) +
				" AND context = " + self.pg.dollarize(JSON.stringify(context)))
				.then(function(result){
					if( result.rows.length == 1 ){
						digestDeferred.resolve(JSON.parse(result.rows[0].result));
					} else if ( !result.rows.length ){
						var value = fn.apply(context, args),
							spit = undefined;

						if( value.constructor && value.constructor.name == "Promise" ){
							value.then(function(result){
								spit = result;
								self.writeResult(name, args, context, spit)
									.catch(function(err){
										self.emit("err", err);
									})
									.fin(function(){
										digestDeferred.resolve(spit);
									});
							}).catch(digestDeferred.reject);
						} else {
							spit = value;
							self.writeResult(name, args, context, spit)
								.catch(function(err){
									self.emit("err", err);
								})
								.fin(function(){
									digestDeferred.resolve(spit);
								});
						}

					}
				}).catch(digestDeferred.reject);			

			return digestDeferred.promise;
		};

		deferred.resolve(digested);
	}

	//check if table already exists, if not create it
	var existing = name in this.belly;

	if( !existing ){
		this.createTable(name)
			.then(createFunction)
			.catch(deferred.reject);
	} else {
		createFunction();
	}

	return deferred.promise;
}

Kirby.prototype.createContract = function(name){
	var contract = new this.pg.Contract({
		tableName: name,
		columns: [{
			name: "_id",
			type: "SERIAL PRIMARY KEY"
		},
		{
			name: "args",
			type: "TEXT NOT NULL"
		},
		{
			name: "result",
			type: "TEXT"
		},
		{
			name: "context",
			type: "TEXT"
		}],
		constraint: {
			unique: ["args", "context"]
		}
	});

	this.contracts[name] = contract;

	return contract;
}

Kirby.prototype.createTable = function(name){
	var deferred = Q.defer(),
		self = this;

	var contract = this.createContract(name);

	this.pg.queryPromise(contract.createTableString())
		.then(function(){
			self.belly[name] = true;
			deferred.resolve();
		}).catch(deferred.reject);

	return deferred.promise;
}

Kirby.prototype.writeResult = function(name, args, context, spit){

	return this.pg.queryPromise(this.pg.buildSQLInsertString(name,
		this.contracts[name].getColumns(),
		[this.pg.dollarize(JSON.stringify(args)),
		 this.pg.dollarize(JSON.stringify(spit)),
		 this.pg.dollarize(JSON.stringify(context))]));
}

Kirby.prototype.clear = function(name){
	return this.pg.queryPromise("DROP TABLE " + name.toLowerCase());
}

module.exports = Kirby;