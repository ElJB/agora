var pgHelper = require('pg-helper'),
	EventEmitter = require('events').EventEmitter,
	Q = require('q');

var LOG = __filename + ": ";

var Kirby = function(dbConnect){
	var self = this;

	this.pg = new pgHelper(dbConnect),
	this.belly = {},
	this.contracts = {},
	this.ready = false;
}

Kirby.prototype.__proto__ = EventEmitter.prototype;

Kirby.prototype.swallow = function(fn){
	var deferred = Q.defer(),
		self = this;

	if( !fn.name ){
		throw new Error(LOG + "Anonymous function");
	}

	var name = fn.name.toLowerCase();

	function digested(){
		var digestDeferred = Q.defer(),
			args = arguments;
		
		// detech if this is 'global'
		if( this.global === this ){
			var context = undefined;
		} else {
			var context = this;
		}

		function callPrimitive(){
			var primitiveDeferred = Q.defer(),
				value = fn.apply(context, args);

			if( value.constructor && value.constructor.name == "Promise" ){
				value.then(function(result){
					primitiveDeferred.resolve([name, args, context, result])
				}).catch(primitiveDeferred.reject);
			} else {
				primitiveDeferred.resolve([name, args, context, value]);
			}

			return primitiveDeferred.promise;
		}

		if( !self.ready ){
			self.pg.getTables()
				.then(function(result){
					result.rows.forEach(function(row){
						self.belly[row.table_name] = true;
						self.createContract(row.table_name);
					});
					self.ready = true;
					self.emit("ready");

					digestion();
				}).catch(digestDeferred.reject);
		} else {
			digestion();
		}

		function digestion(){
			//check if table already exists, if not create it
			var existing = name in self.belly;

			if( !existing ){

				self.createTable(name)
					.then(callPrimitive)
					.then(function(argsArray){
						return self.writeResult(argsArray);
					})
					.then(digestDeferred.resolve)
					.catch(digestDeferred.reject);

			} else {
				self.pg.queryPromise("SELECT result FROM " + name + " WHERE args = " + self.pg.dollarize(JSON.stringify(args)) +
					" AND context = " + self.pg.dollarize(JSON.stringify(context)))
					.then(function(result){
						if( result.rows.length == 1 ){
							digestDeferred.resolve(JSON.parse(result.rows[0].result));
						} else if ( !result.rows.length ){
							callPrimitive()
								.then(function(argsArray){
									return self.writeResult(argsArray);
								})
								.then(digestDeferred.resolve)
								.catch(digestDeferred.reject);
						}
					}).catch(digestDeferred.reject);
			}
		}
				

		return digestDeferred.promise;
	}

	return digested;
}

Kirby.prototype.createContract = function(name){
	var contract = new this.pg.Contract({
		tableName: name,
		columns: [{
			name: "_id",
			type: "SERIAL PRIMARY KEY"
		},
		{
			name: "args",
			type: "TEXT NOT NULL"
		},
		{
			name: "result",
			type: "TEXT"
		},
		{
			name: "context",
			type: "TEXT"
		}],
		constraint: {
			unique: ["args", "context"]
		}
	});

	this.contracts[name] = contract;

	return contract;
}

Kirby.prototype.createTable = function(name){
	var deferred = Q.defer(),
		self = this;

	var contract = this.createContract(name);

	this.pg.queryPromise(contract.createTableString())
		.then(function(){
			self.belly[name] = true;
			deferred.resolve();
		}).catch(deferred.reject);

	return deferred.promise;
}

Kirby.prototype.writeResult = function(argsArray){
	var deferred = Q.defer(),
		name = argsArray[0],
		args = argsArray[1],
		context = argsArray[2],
		result = argsArray[3];

	this.pg.queryPromise(this.pg.buildSQLInsertString(name,
		this.contracts[name].getColumns(),
		[this.pg.dollarize(JSON.stringify(args)),
		 this.pg.dollarize(JSON.stringify(result)),
		 this.pg.dollarize(JSON.stringify(context))]))
		.then(function(){
			deferred.resolve(result);
		}).catch(deferred.reject);

	return deferred.promise;
}

Kirby.prototype.clear = function(name){
	return this.pg.queryPromise("DROP TABLE " + name.toLowerCase());
}

module.exports = Kirby;