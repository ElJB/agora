var lemmatize = require('lemmatize'),
	kue = require('kue'),
	rpcClient = require('rabbit-rpc').Client,
	Q = require('q'),
	spawn = require('child_process').spawn,
	path = require('path');

var rater = new rpcClient('sentence_rating'),
	rabbit = spawn('rabbitmq-server'),
	raterServer = spawn('python', [path.resolve(__dirname, 'opinion-rating/sentence_rater.py').toString()]);

raterServer.stderr.on('data', function(data){
	console.log("sentence_rater process err:\n" + data.toString());
});
rabbit.stderr.on('data', function(data){
	console.log("rabbitmq-server process err:\n" + data.toString());
});

var sentenceRe = /[ABCDEFGHIJKLMNOPQRSTUVWXYZ][^\.?!]+[^ABCDEFGHIJKLMNOPQRSTUVWXYZ][\.?!]/g;

var trees = [];
function parseSentence(sentences){
	var deferred = Q.defer(),
		sentence = sentences.split(0, 1)[0];

	var alpage = new Alpage(sentence);

	alpage.parse()
		.then(function(tree){
			trees.push(tree);
		})
		.catch(function(err){
			console.log(err.stack);
		}).fin(function(){
			if( sentences.length ){
				parseSentence(sentences)
					.then(deferred.resolve)
			} else {
				deferred.resolve(trees);
			}
		});

	return deferred.promise;
}

function deny(trees){
	trees.forEach(function(tree){
		tree.not();
	});

	return trees
}

function stringify(trees){
	return trees.map(function(tree){
		return tree.lemmaString();
	}).reduce(function(a, b){
		return a + " " + b;
	});
}

module.exports = function(text){
	var deferred = Q.defer();

	// use only first and last paragraph
	var paragraphs = text.split("\n\n");
	var lastParagraph = paragraphs[paragraphs.length-1],
		firstParagraph = paragraphs[0];

	// parse each sentence
	var sentences = (lastParagraph + firstParagraph).match(sentenceRe);
	parseSentence(sentences)
		.then(deny) // add NOT_ tags to lemma
		.then(stringify) // tree to String
		//.then(rater.call)
		.catch(deferred.reject);

	return deferred.promise;
}