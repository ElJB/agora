/*
Rc-rebates exposes a Debates class,
The constructor takes a folderUrl and title as arguments
and builds an array of orators interventions and a
summary of their opinion

Status:
- fetching speeches OK
- needs to refine the speeches selection process
*/

var events = require('events'),
	util = require('util'),
	Crawler = require('crawler').Crawler,
	crawler = new Crawler({
		"maxConnections": 10
	}),
	Set = require('simplesets').Set;

var sentenceRe = /[ABCDEFGHIJKLMNOPQRSTUVWXYZ][^\.?!]+[^ABCDEFGHIJKLMNOPQRSTUVWXYZ][\.?!]/g;

var Debates = function(folderUrl, title){
	if( !title || !folderUrl ){
		throw new Error("Invalid constructor call");
	}
	this.url = folderUrl,
	this.title = title,
	this.isStructured = false,
	this._interventions = [],
	this.groups = {},
	this.orators = {};
	/*
	Sorted list of MP interventions
	{
		name:
		group:
		text:
	}
	*/
	this._opinions = [];

	var self = this;

	crawler.queue([{
		uri: folderUrl,
		callback: function(err, result, $){

			if( err ){ return self.emit("err", err) }

			var debatesUrl = $(".seances_dossier").find("a").toArray().map(function(e){return e.href});

			self.fetchDebates(debatesUrl);
		}
	}]);
}

util.inherits(Debates, events.EventEmitter);

Debates.prototype.fetchDebates = function(debatesUrl){
	var self = this;

	crawler.queue([{
		uri: debatesUrl.splice(0, 1)[0],
		callback: function(err, result, $){

			if( err ){ return self.emit("err", err) }

			var inLaw = false,
				inOpinions = false,
				endOpinions = false;

			var titleRe = new RegExp("<h2.*<a href=\".+\">" + self.title + "<\/a>.*<\/h2>"),
				opinionsRe = new RegExp("<h3.*<a href=\".+\">Présentation<\/a>.*<\/h3>|<h3.*<a href=\".+\">Discussion générale<\/a>.*<\/h3>|\
					<h3.*<a href=\".+\">" + self.title + "<\/a>.*<\/h3>");
				endOpinionsRe = new RegExp("<h3.*<a href=\".+\">Discussion des articles<\/a>.*<\/h3>");

			var interventions = $(".intervention").filter(function(i, e){
				// if intervention contains titles h2 h3
				// then switch inLaw || inOpinions

				if( e.innerHTML.match(/<h3|<h2/)){
					inLaw = titleRe.exec(e.innerHTML),
					inOpinions = opinionsRe.exec(e.innerHTML),
					endOpinions = endOpinions || endOpinionsRe.exec(e.innerHTML);
				}
				
				inLaw = e.innerHTML.match()
				return inLaw && inOpinions;
			});

			self._interventions.push(interventions);

			if( !endOpinions && debatesUrl.length ){
				self.fetchDebates(debatesUrl);
			} else {
				self.emit("fetched");
				self.structure();
			}

		}
	}])
}

Debates.prototype.getInterventionByOrator = function(orator){
	if( !this.isStructured ){ throw new Error("Debates is not yet structured")}
	return this.orators[orator].reduce(function(a, b){
		return a + b;
	});
}

Debates.prototype.getOratorsByGroup = function(group){
	if( !this.isStructured ){ throw new Error("Debates is not yet structured")}
	return this.groups[group];
}

Debates.prototype.getInterventionByGroup = function(group){
	if( !this.isStructured ){ throw new Error("Debates is not yet structured")}
	var self = this;
	return this.groups[group].map(function(orator){
		self.getInterventionByOrator(orator);
	}).reduce(function(a, b){
		return a.concat(b);
	});
}

/*
Transform isolated interventions into a structured object
*/
Debates.prototype.structure = function(){
	var self = this;

	var groupRe = /\(Groupe parlementaire : ([\w\s]+)/,
		nameRe = /^(.+) --/;

	//TO DO: modify connector logic to account for government intervention (without img)
	this._interventions.forEach(function(interventions){
		interventions.find('img').parent().parent().parent()
			.each(function(i, e){
				var imgTitle = e.getElementsByTagName('img')[0].getAttribute('title');

				self._opinions.push({
					name: nameRe.exec(imgTitle)[1],
					group: groupRe.exec(imgTitle)[1],
					text: htmlToText(e.getElementsByClassName('texte_intervention')[0].innerHTML)
				});
			});
	});

	this._opinions.forEach(function(opinion){
		if( opinion.text.match(sentenceRe) && opinion.text.match(sentenceRe).length > 2 ){

			if( !self.groups[opinion.group] ){
				self.groups[opinion.group] = new Set();
			}
			self.groups[opinion.group].add(opinion.name);

			if( !self.orators[opinion.name] ){
				self.orators[opinion.name] = [];
			}

			self.orators[opinion.name].push(opinion.text);
		}
	});

	this.isStructured = true;
	this.emit("structured");
}

var htmlToText = function(html){
	return html.replace(/<p>/g, "\n\n")
		.replace(/<\/p>/g, "")
		.replace(/<br>|<\/br>/g, "\n")
		.replace(/<[^>]*>/g, "");
}


module.exports = Debates;