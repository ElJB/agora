/*
Rc-rebates exposes a Debates class,
The constructor takes a folderUrl and title as arguments
and builds an array of orators interventions and a
summary of their opinion

Status:
- fetching speeches OK
- needs to refine the speeches selection process
*/

var events = require('events'),
	util = require('util'),
	Crawler = require('crawler').Crawler,
	crawler = new Crawler({
		"maxConnections": 10
	}),
	Set = require('simplesets').Set,
	assert = require('assert');

var sentenceRe = /[ABCDEFGHIJKLMNOPQRSTUVWXYZ][^\.?!]+[^ABCDEFGHIJKLMNOPQRSTUVWXYZ][\.?!]/g;

var Debates = function(folderUrl, title){
	if( !title || !folderUrl ){
		throw new Error("Invalid constructor call");
	}
	this.url = folderUrl,
	this.title = title,
	this.isStructured = false,
	this.sections = ["presentations", "discussions"],
	this._sections = {
		presentations: [],
		discussions: []
	},
	this.interventionTree = {},
	this.groups = {},
	this.orators = {};
	/*
	Sorted list of MP interventions
	{
		name:
		group:
		text:
	}
	*/
	this._opinions = [];

	var self = this;

	crawler.queue([{
		uri: folderUrl,
		callback: function(err, result, $){

			if( err ){ return self.emit("err", err) }

			var debatesUrl = $(".seances_dossier").find("a").toArray().map(function(e){return e.href});

			self.fetchDebates(debatesUrl);
		}
	}]);
}

util.inherits(Debates, events.EventEmitter);

Debates.prototype.fetchDebates = function(debatesUrl){
	var self = this;

	crawler.queue([{
		uri: debatesUrl.splice(0, 1)[0],
		callback: function(err, result, $){

			if( err ){ return self.emit("err", err) }

			var inLaw = false,
				inPresentation = false,
				endPresentation = false,
				inDiscussion = false,
				endDiscussion = false;

			var titleRe = new RegExp("<h2.*<a href=\".+\">" + self.title + "<\/a>.*<\/h2>"),
				presentationRe = new RegExp("<h3.*<a href=\".+\">Présentation<\/a>.*<\/h3>"),
				discussionRe = new RegExp("<h3.*<a href=\".+\">Discussion générale<\/a>.*<\/h3>|\
					<h3.*<a href=\".+\">" + self.title + "<\/a>.*<\/h3>");
				articleRe = new RegExp("<h3.*<a href=\".+\">Discussion des articles<\/a>.*<\/h3>");

			$(".intervention").each(function(i, e){
				// if intervention contains titles h2 h3
				// then switch inLaw, inPresentation, inDiscussion ...

				if( e.innerHTML.match(/<h3|<h2/)){
					inLaw = titleRe.exec(e.innerHTML),
					inPresentation = presentationRe.exec(e.innerHTML),
					endPresentation = endPresentation || discussionRe.exec(e.innerHTML) && inLaw,
					inDiscussion = discussionRe.exec(e.innerHTML),
					endDiscussion = endDiscussion || articleRe.exec(e.innerHTML) && inLaw;
				}
				
				if( inLaw && inPresentation && !endPresentation ){
					self._sections.presentations.push(e);
				} else if ( inLaw && inDiscussion && !endDiscussion ){
					self._sections.discussions.push(e);
				}
			});

			if( !endDiscussion && debatesUrl.length ){
				self.fetchDebates(debatesUrl);
			} else {

				self.emit("fetched");
				self.structure();
			}

		}
	}])
}


Debates.prototype.getOratorsByGroup = function(group){
	if( !this.isStructured ){ throw new Error("Debates is not yet structured")}
	return Object.keys(this.interventionTree[group]);
}

Debates.prototype.getGroups = function(){
	return Object.keys(this.interventionTree);
}

Debates.prototype.getOpinions = function(){
	var results = [];

	for( group in this.interventionTree ){
		for( orator in this.interventionTree[group] ){
			for( section in this.interventionTree[group][orator])
				results.push({
					name: orator,
					group: group,
					section: section,
					text: this.interventionTree[group][orator][section]
				});
		}
	}

	return results;
}

/*
Transform isolated interventions into a structured object
*/
Debates.prototype.structure = function(){
	var self = this;

	var groupRe = /\(Groupe parlementaire : ([\w\s]+)/,
		nameRe = /^(.+) --/;

	try {

		//TODO: refactor presentations and discussions as object sections

		this.sections.forEach(function(section){
			self._sections[section] = self._sections[section].filter(function(e){
				return e.getElementsByClassName('perso')[0];
			}).map(function(e){
				if( e.getElementsByTagName('img')[0] ){
					//member of parliament intervention
					var imgTitle = e.getElementsByTagName('img')[0].getAttribute('title');

					return {
						name: nameRe.exec(imgTitle)[1],
						group: groupRe.exec(imgTitle)[1],
						section: section,
						text: htmlToText(e.getElementsByClassName('texte_intervention')[0].innerHTML)
					};
				}

				//governement intervention
				return {
					name: e.getElementsByClassName('perso')[0].innerHTML,
					group: "Gouvernement",
					section: section,
					text: htmlToText(e.getElementsByClassName('texte_intervention')[0].innerHTML)
				}
			});
		});

		if( !self._sections.presentations.length ){
			throw new Error("No presentations found: " + self.title);
		}

		if( !self._sections.discussions.length ){
			throw new Error("No discussions found: " + self.title);
		}
		
		this.sections.forEach(function(section){

			self._sections[section].forEach(function(opinion){

				if( opinion.text.match(sentenceRe) && opinion.text.match(sentenceRe).length > 2 ){

					opinion.text = opinion.text.replace(/&nbsp;/g, " ");

					if( !self.interventionTree[opinion.group] ){
						self.interventionTree[opinion.group] = {};
					}

					if( !self.interventionTree[opinion.group][opinion.name] ){
						self.interventionTree[opinion.group][opinion.name] = {}
					}

					if( !self.interventionTree[opinion.group][opinion.name][section] ){
						self.interventionTree[opinion.group][opinion.name][section] = "";
					}

					self.interventionTree[opinion.group][opinion.name][section] += opinion.text;
				}
			});
		});

		

		for( key in this.groups ){
			this.groups[key] = this.groups[key].array();
		}

	} catch(e) { return this.emit("err", e); }	

	this.isStructured = true;
	this.emit("structured", this);
}

var htmlToText = function(html){
	return html.replace(/<p>/g, "\n\n")
		.replace(/<\/p>/g, "")
		.replace(/<br>|<\/br>/g, "\n")
		.replace(/<[^>]*>/g, "");
}


module.exports = Debates;