var Word = require('./word.js');

var ParsedTree = function(xmlTree){
	var self = this;

	this.groups = xmlTree.Document.Sentence[0].G,
	this.relations = xmlTree.Document.Sentence[0].R;
	this.words = xmlTree.Document.Sentence[0].W;

	this.groups = this.groups.map(function(e){
		var group = e.$;
		group.words = e.W.map(function(f){ return f.$ });
		return group;
	});

	this.relations = this.relations.map(function(e){
		var relation = e.$;
		var keys = Object.keys(e);
		keys.splice(keys.indexOf('$'), keys.indexOf('$') + 1);
		for( i in keys ){
			relation[keys[i]] = e[keys[i]][0].$.ref;
		}
		return relation;
	});

	this.words = {}

	if( xmlTree.Document.Sentence[0].W ){
		xmlTree.Document.Sentence[0].W.forEach(function(w){

			self.words[w.$.id] = new Word({
				lemma: w.$.lemma,
				pos: w.$.pos
			}, self);

		});
	}


	this.structure();


}

ParsedTree.prototype.structure = function(){
	var self = this;

	this.groups.forEach(function(group){
		group.words.forEach(function(word){
			self.words[word.id] = new Word({
				pos: word.pos,
				lemma: word.lemma,
				group: group.id,
				mstag: word.mstag
			}, self)
		});
	});

	var parents = ["auxiliaire", "verbe", "coordonnant", "nom", "adjectif", "adverbe", "preposition", "appose", "premier"];

	this.relations.forEach(function(relation){

		try {
			for( i in parents ){
				if( parents[i] in relation ){
					var parent = relation[parents[i]],
						parentKey = parents[i];
					break;
				}
			}

			if( !parent ){
				throw new Error("unknown parent");
			}

			var childrenKeys = Object.keys(relation).filter(function(key){
				return (["type", "id"].concat([parentKey])).indexOf(key) == -1 && relation[key];
			});

			var children = []
			childrenKeys.forEach(function(key){
				//prevent circular hierarchy
				if( relation[key] != self.words[parent]._parent ){
					children.push([relation.type, relation[key]]);
				}

				self.words[relation[key]]._parent = [relation.type, parent];
			});

			if( !self.words[parent]._children ){
				self.words[parent]._children = children;
			} else {
				self.words[parent]._children = self.words[parent]._children.concat(children);
			}
		} catch (err){
			console.log(err.stack);
			console.log(relation);
		}
		

	});

	this.groups.forEach(function(group){
		var parents = {};

		Object.keys(self.words).forEach(function(key){
			if( self.words[key].group && !parents[self.words[key].group] && self.words[key]._children ){
				parents[self.words[key].group] = key;
			}
		});

		Object.keys(self.words).forEach(function(key){
			if( !self.words[key]._parent ){
				self.words[key]._parent = ["group", parents[self.words[key].group]];
			}
		});

	});
}

ParsedTree.prototype._group = function(group){
	var self = this;

	return Object.keys(this.words).filter(function(key){
		return self.words[key].group == group;
	}).map(function(key){
		return self.words[key];
	});
}

ParsedTree.prototype.not = function(){
	var self = this;

	Object.keys(this.words).forEach(function(key){

		if( self.words[key].pos == "clneg" ){
			self.words[key].deny();
			var verb = self.words[key].parent(["group", "MOD-V"]);
			if( verb ){
				verb.deny(true);
			}

		}

	});
}

ParsedTree.prototype.lemmaString = function(){

	var string = "",
		seed = "E1F",
		i = 1;

	while( this.words[seed + i]){
		string += this.words[seed + i].lemma + "_" + this.words[seed + i].pos.toUpperCase() + " ";
		i++;
	}

	return string.substr(0, string.length - 1);
}

ParsedTree.prototype.tense = function(){
	var self = this,
		tense = {};

	Object.keys(this.words).forEach(function(key){
		if( this.words[key].pos == "v" ){

		}
	});
}

module.exports = ParsedTree;